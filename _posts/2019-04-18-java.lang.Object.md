---
layout:     post
title:      java.lang.Object
subtitle:   本文为 Java 源码阅读中的一节，重要程度为 1 
date:       2019-04-15
author:     NONGFAH
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 源码
---

> Object 类内域为空，主要方法如下

# 构造器

|修饰符|方法名|描述|  
|:--|:--|:--|  
|public|Object()|默认构造器|  

# 方法区

### 方法列表

|修饰符|返回值|方法名|描述|  
|:---|:---|:---|:---|  
| protected&nbsp;native     |Object                 | clone()                       | 创建并返回此对象的副本 |  
| protected native          |void                   | finalize()                    | 当垃圾收集器确定不再有对该对象的引用时，垃圾收集器在对象上调用该方法 |  
| public native             |Class<&nbsp;?&nbsp;>   | getClass()                    | 返回此 Object 的运行时类 |  
| public native             |int                    | hashCode()                    | 返回对象的哈希码值 |  
| public                    |boolean                | equals(Object&nbsp;obj)       | 指示一些其他对象是否等于此 |  
| public                    |String                 | toString()                    | 返回对象的字符串表示形式 |  
| public native             |void                   | notify()                      | 唤醒正在等待对象监视器的单个线程 |  
| public native             |void                   | notifyAll()                   | 唤醒正在等待对象监视器的所有线程 |  
| public native             |void                   | wait()                        | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |  
| public                    |void                   | wait(long&nbsp;timeout)       | 导致当前线程等待，直到另一个线程调用 notify()方法或该对象的 notifyAll()方法，或者指定的时间已过 |  
| public                    |void                   | wait(long timeout, int nanos) | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或者某些其他线程中断当前线程，或指定的时间已过 |  

#### clone()  

protected Object clone() throws CloneNotSupportedException  
创建并返回此对象的副本。  
一般情况下，对于任何对象x ， x.clone() != x  && x.clone().getClass() == x.getClass() && x.clone().equals(x)，  
即 x 的副本 y 所引用对象与 x 所引用的不为同一个， x 的运行时类与 y 相同，x 的实际内容与 y 相同。  
如果调用 clone() 方法的类没有实现 Cloneable 接口，则抛出 CloneNotSupportedException 异常，  
Object类本身并不实现 Cloneable 接口 ，因此在类别为 Object 的对象上调用 clone() 方法将导致运行时抛出异常。  
所有数组都被认为是实现 Cloneable 接口 ，并且数组类型T[]的clone方法的返回类型是T[] ，其中T是任何引用或原始类型。  
对于没有实现 Cloneable 接口的类，clone() 方法将创建类的新实例，并将其所有字段初始化为待拷贝对象相应字段的内容，就像通过赋值一样。 这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作  
 
Object类的克隆方法为浅克隆，下面代码演示浅拷贝概念
        public class Person implements Cloneable{
            String name;
            Car car;
            @Override
            protected Object clone() throws CloneNotSupportedException {
                return  super.clone();
            }
            //省略get/set/toString方法
        }
        public class Car{
            String brand; //品牌
            int price;
            //省略get/set/toString方法
        }
        public static void main(String[] args) throws CloneNotSupportedException{
        //演示代码
        //创建待拷贝实例
        Car car = new Car();
        car.setBrand("长城");
        car.setPrice(10000);
        Person person =  new Person();   
        person.setName("赵子龙");
        person.setCar(car);
        //进行拷贝
        Person personCopy =(Person) person.clone();
        //验证拷贝方式是否为浅拷贝
        personCopy.getCar().setBrand("福特");
        personCopy.setName("姜子牙");
        System.out.println(person.toString());
        System.out.println(personCopy.toString());
        //可以看到，在修改副本的 car 属性时，正本的 car 也被修改为 “福特”。
        //当对象中含有可变的引用类型属性时，在复制得到的新对象对该引用类型属性内容进行修改，原始对象相应的属性内容也会发生变化，这就是"浅拷贝"的现象
        }
        
        
        
        
        
        
        



 